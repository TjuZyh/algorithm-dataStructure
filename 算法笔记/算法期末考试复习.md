两个小时

#### 复习范围

**应用题：**

​	~~并查集：quickUnion...~~

​	~~排序：排序次数、稳定性、时间复杂度、一些细节~~

​	~~BST，23树，红黑树，平衡二叉树时间复杂度，最好最坏情况，平均情况~~

​	~~图：遍历，深度广度，求最小生成树，最短路，关键路~~

​	~~子串的搜索：KMP算法，给一个串输入字符转换什么状态~~

**代码题：**

1）栈 队列  2）子串搜索

#### **复习笔记**

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211113201855217.png" alt="image-20211113201855217" style="zoom:50%;" />

##### 1、并查集

**quick-find（快速查询）：**

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211113202711857.png" alt="image-20211113202711857" style="zoom:33%;" />

初始化数组都为自己的id

如果是同一集合，那么在数组中存储相同的数字

但是合并的效率太慢，因为需要更改一个集合的全部下标

处理N个对象上的N个union命令序列需要n^2个数组访问

**quick-union（快速合并）：**

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211113203238244.png" alt="image-20211113203238244" style="zoom:33%;" />

初始化数组都为自己的id

如果需要合并，那么只需要把id变为合并集合的root即可

但是合并的效率依然太慢，因为构造出的树不是平均的，树的层数不平均，可能会很高

**改进：**

**1）Weighted quick-union（加权快速合并）**

追踪树的层数，将小树连接在大树上，节点的深度最多为lgN 

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211113203801823.png" alt="image-20211113203801823" style="zoom:33%;" />

**三种方式比较**

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211113204154901.png" alt="image-20211113204154901" style="zoom:33%;" />

**2）路径压缩**

在计算p的根之后，将每个被检查节点的id设置为指向该根

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211113205724654.png" alt="image-20211113205724654" style="zoom:33%;" />

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211113205758622.png" alt="image-20211113205758622" style="zoom:33%;" />

***总结：**

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211113210010628.png" alt="image-20211113210010628" style="zoom:33%;" />

##### 2、时间复杂度举例

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211113210956370.png" alt="image-20211113210956370" style="zoom:33%;" />

##### **3、栈 队列**

**栈：**

​	顺序栈、共享栈、链式栈

**队列：**

​	循环队列：

​		把数组“掰弯”，形成一个环。rear指针到了下标为maxSize的位置还能继续指回到下标为0的地方。这样首尾相连的顺序存储的队列就叫循环队列；

​		入队：`rear=(rear+1)%MaxSize`	

​		出队：`front=(front+1)%MaxSize`

​		判空：rear = front

​	链式队列、双端队列

##### **4、排序**

![image-20211113213040549](/Users/zyh/Library/Application Support/typora-user-images/image-20211113213040549.png)

![image-20211114123323043](/Users/zyh/Library/Application Support/typora-user-images/image-20211114123323043.png)

1、冒泡排序：每一次遍历都将最大的数冒泡到最后。稳定

2、选择排序：每一次遍历都选择一个最小的数，把他和前面的数交换。**不稳**（5 6 1 5 7）

3、插入排序：每一步将一个待排序的数据插入到前面已经排好序的有序序列中，直到插完所有元素为止。稳定

4、希尔排序：先将待排记录序列分割成为若干子序列分别进行插入排序，待整个序列中的记录"基本有序"时，再对全体记录进行一次直接插入排序。**不稳**（一次插入排序稳定，但是不同的插入排序再合并会导致相同元素的位置发生变化）

5、归并排序：假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到![img](https://img-blog.csdn.net/20180610100804187)（![img](https://img-blog.csdn.net/20180610100859572)表示不小于x的最小整数）个长度为2(或者是1)的有序子序列，再两两归并。如此重复，直到得到一个长度为n的有序序列为止。**稳定**

6、快速排序：每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。**不稳**（5 7 7 1 1，排序后7的位置变化）

**排序过程**

7、堆排序：先利用数组表示出二叉树后，调整二叉树为大顶堆；后将根节点的值和堆数组的末尾元素交换，再将剩余序列重新构造成一个大顶堆，反复执行，最终得到一个有序序列。**不稳**（3 27 36 27，构造大顶堆以及交换的过程中均可能使数据发生位置变化）

**排序过程：swim，sink**

##### 5、二叉搜索树

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211114133923437.png" alt="image-20211114133923437" style="zoom:50%;" />

###### **2-3查找树**

为了保证查找树的平衡性，允许树中的一个结点保存多个键。

一棵标准的二叉查找树中的结点称为**2-结点**(含有一个键和两条链接)。引入**3-结点**，它含有两个键和三条链接。

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211114134630184.png" alt="image-20211114134630184" style="zoom:50%;" />

- 2-结点，含有一个键(及其对应的值)和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。
- 3-结点，含有两个键(及其对应的值)和三条链接，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。
- 指向一棵空树的链接称为空链接

**1、查找**

和二叉查找树的查找方式类似，要查找value是否在树里。首先将它和root的key进行比较，小于就去其左子树进行递归查找，大于就去其右子树进行递归查找。如果找到的节点为null，则说明没有找到。

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211114135059982.png" alt="image-20211114135059982" style="zoom:50%;" />

**2、插入**

- 插入到2-结点：首先查找到要插入的2结点，得到该节点的key，并将改结点替换为数据为key和value的一个3结点。

  <img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211114135358410.png" alt="image-20211114135358410" style="zoom:50%;" />

- 插入到3-结点：

  - 只包含一个3-结点：假设这个节点能存放三个元素，暂时使其变成一个4-node节点，同时他包含四个子节点。然后，我们将这个4-node节点的中间元素提升，左边的节点作为其左节点，右边的元素作为其右节点。插入完成，变为平衡2-3查找树，树的高度从0变为1。

    <img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211114135912964.png" alt="image-20211114135912964" style="zoom:50%;" />

  - 节点是3结点，父节点是2节点：把新的元素插入到3结点中，将其变成一个临时的4结点，然后将其中间元素提升到父节点中，把父节点变成一个3结点，然后将左右结点调整位置

    <img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211114140025881.png" alt="image-20211114140025881" style="zoom:50%;" />

  - 节点是3-结点，父结点也是3-结点：类比上面的方法，将该节点拆分后把中间元素提升，这样父节点就变成了一个4结点，只需继续将中间元素提升，直到遇到一个父节点为2节点的并且将其变为3结点。

    <img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211114140330806.png" alt="image-20211114140330806" style="zoom:50%;" />

    

  - 根节点分裂：有一种情况就是从根节点到子节点都是3节点的时候，如果要插入新的元素，按照之前的提升方法，根节点就会变为4结点，这时就要讲根节点分裂为两个2结点，然后树高+1。

  **查询效率：**由树的查找方式可以知道查找的时间性能和树的高度息息相关

  - 最坏的情况：所有结点都是2结点，性能为O(log2N)。
  - 最好的情况：所有的节点都是3结点，性能为O(log3N)。

  <img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211114142849287.png" alt="image-20211114142849287" style="zoom:50%;" />

###### 红黑树

**23查找树转换红黑树**

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211114160447939.png" alt="image-20211114160447939" style="zoom:50%;" />

**红黑树转换23查找树**

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211114161644029.png" alt="image-20211114161644029" style="zoom:50%;" />

**红黑树的特性：**

A BST such that:

- No node has two red links connected to it.
-  Every path from root to null link has the same number of black links. 
- Red links lean left.

**红黑树的操作：**

**1、左转**

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211114161928112.png" alt="image-20211114161928112" style="zoom:50%;" />

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211114161941164.png" alt="image-20211114161941164" style="zoom:50%;" />

**2、右转**

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211114162228800.png" alt="image-20211114162228800" style="zoom:50%;" />

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211114162241677.png" alt="image-20211114162241677" style="zoom:50%;" />

**3、颜色翻转**

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211114162557394.png" alt="image-20211114162557394" style="zoom:50%;" />

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211114162616107.png" alt="image-20211114162616107" style="zoom:50%;" />



**4、插入节点**

- 1、在2结点插入：在叶子节点处插入新节点，由于红色路径只能出现在左侧，则需要左转

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211114163230878.png" alt="image-20211114163230878" style="zoom:50%;" />



- 2、在特殊的2结点插入

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211114163746358.png" alt="image-20211114163746358" style="zoom:50%;" />

- 3、在3结点插入：左右路径均为红，则颜色翻转

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211114164016182.png" alt="image-20211114164016182" style="zoom:50%;" />

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211114164217349.png" alt="image-20211114164217349" style="zoom:50%;" />

**查找、插入、删除效率：**

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211114164311106.png" alt="image-20211114164311106" style="zoom:50%;" />

##### 6、图论

**1、表示方法：**

- **邻接表表示：**

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211114191158204.png" alt="image-20211114191158204" style="zoom:33%;" />

- **邻接矩阵表示：**

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211114191240342.png" alt="image-20211114191240342" style="zoom:33%;" />

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211114204729099.png" alt="image-20211114204729099" style="zoom:50%;" />

**2、DFS:**

**3、BFS：**

**4、连通分量：**

​	连通分量、强连通分量

​	强连通分量算法：

​	**Kosaraju-Sharir：两次DFS**

- 先DFS逆图的序列

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211114203740438.png" alt="image-20211114203740438" style="zoom:50%;" />	

- 后DFS原图，按第一个DFS给定的顺序考虑顶点

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211114203959046.png" alt="image-20211114203959046" style="zoom:50%;" />

**5、拓扑排序：**拓扑排序是对DAG（有向无环图）上的节点进行排序，使得对于每一条有向边 ![[公式]](https://www.zhihu.com/equation?tex=u%5Crightarrow+v) ， ![[公式]](https://www.zhihu.com/equation?tex=u) 都在 ![[公式]](https://www.zhihu.com/equation?tex=v) 之前出现。简单地说，是在不破坏节点**先后顺序**的前提下，把**DAG**拉成一条**链**。

拓扑排序最经典的算法是**Kahn算法**。首先，先拿出所有入度为0的点排在前面，并在原图中将它们删除，重复直到全部节点删除。

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211114201426568.png" alt="image-20211114201426568" style="zoom:50%;" />

**6、最小生成树：**

**kruskal算法：**按边大小排序依次合并，每次都有新的点加入且不成环

**prim算法：**从一个点开始，找最近的点合并成一个子集，找离这个子集最近的点继续合并，直到子集中包含全部点

**7、最短路径：**

**dijkstra：**有向网中的某个顶点到其余所有顶点的最短路径，每次选择最短的邻边进行遍历，判断，加和，递归。

首先从起始点开始，按照一定的时针顺序，遍历其到每一个顶点连线的距离，将这些距离进行排列，然后选出最短的一条，到达对应的顶点，然后接着执行这个顺序，直到到达最终的点即可。

**floyd：**任意两顶点之间的最短路径。

**Topological sort algorithm：**

- Consider vertices in topological order. 
- Relax all edges incident from that vertex

**8、关键路：**

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211114222043797.png" alt="image-20211114222043797" style="zoom:50%;" />

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211114222100910.png" alt="image-20211114222100910" style="zoom:70%;" />

##### 7、字符串搜索

**kmp算法：**

给定子串，构造DFA

<img src="/Users/zyh/Library/Application Support/typora-user-images/image-20211115102313504.png" alt="image-20211115102313504" style="zoom:50%;" />

